package org.oddys.timetracking.connection;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;

/**
 * A class that wraps a connection to the data source
 * to manage the complexity of dealing with transactions
 * in the multi-threading environment.
 */
public class ConnectionWrapper implements AutoCloseable {
    private static final Logger LOGGER = LogManager.getLogger();
    private static ConnectionWrapper INSTANCE = new ConnectionWrapper();
    private ThreadLocal<Connection> connectionThreadLocal = ThreadLocal
            .withInitial(() -> ConnectionPool.getInstance().getConnection());
    private ThreadLocal<Boolean> transactionThreadLocal = ThreadLocal.withInitial(() -> false);

    private ConnectionWrapper() {}

    /**
     * Returns an instance of a ConnectionWrapper
     *
     * @return a connection wrapper
     */
    public static ConnectionWrapper getInstance() {
        return INSTANCE;
    }

    /**
     * Returns a connection associated with this ConnectionWrapper in the current thread.
     *
     * @return a connection
     */
    public Connection getConnection() {
        return connectionThreadLocal.get();
    }

    /**
     * Sets a transaction mode for a connection associated with this ConnectionWrapper
     * in the current thread
     *
     * @param isTransaction true if operations should be performed
     *                      as a transaction, false otherwise
     */
    public void setTransaction(boolean isTransaction) {
        transactionThreadLocal.set(isTransaction);
    }

    /**
     * Creates a PreparedStatement object for sending parameterized SQL statements to the database.
     *
     * @param query an SQL statement that may contain one or more '?' in parameter placeholders
     * @return a new default PreparedStatement object containing the pre-compiled SQL statement
     * @throws SQLException if a database access error occurs or this method is called on a closed connection
     *
     * @see Connection#prepareStatement(String)
     */
    public PreparedStatement prepareStatement(String query) throws SQLException {
        return connectionThreadLocal.get().prepareStatement(query);
    }

    /**
     * Creates a default PreparedStatement object that has the capability to retrieve auto-generated keys.
     *
     * @param query an SQL statement that may contain one or more '?' in parameter placeholders
     * @param autoGeneratedKeys a flag indicating whether auto-generated keys should be returned
     * @return a new PreparedStatement object, containing the pre-compiled SQL statement,
     * that will have the capability of returning auto-generated keys
     * @throws SQLException if a database access error occurs or this method is called on a closed connection
     */
    public PreparedStatement prepareStatement(String query, int autoGeneratedKeys)
            throws SQLException {
        return connectionThreadLocal.get().prepareStatement(query, autoGeneratedKeys);
    }

    /**
     * Creates a Statement object for sending SQL statements to the database.
     *
     * @return a new default Statement object
     * @throws SQLException if a database access error occurs or this method is called on a closed connection
     *
     * @see Connection#createStatement()
     */
    public Statement createStatement() throws SQLException {
        return connectionThreadLocal.get().createStatement();
    }

    /**
     * Releases this Connection object's database and JDBC resources immediately
     * instead of waiting for them to be automatically released.
     */
    @Override
    public void close() {
        if (!transactionThreadLocal.get()) {
            try {
                connectionThreadLocal.get().close();
            } catch (SQLException e) {
                LOGGER.error("ConnectionWrapper failed to close a connection", e);
                throw new ConnectionPoolException(e);
            } finally {
                connectionThreadLocal.remove();
            }
        }
    }
}
